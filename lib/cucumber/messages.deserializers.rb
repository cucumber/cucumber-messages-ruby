require 'cucumber/messages.dtos'
require 'json'

# The code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
#

module Cucumber
  module Messages

    class Attachment
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          body: hash[:body],
          content_encoding: hash[:contentEncoding],
          file_name: hash[:fileName],
          media_type: hash[:mediaType],
          source: Source.from_h(hash[:source]),
          test_case_started_id: hash[:testCaseStartedId],
          test_step_id: hash[:testStepId],
          url: hash[:url],
        )
      end
    end

    class Duration
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          seconds: hash[:seconds],
          nanos: hash[:nanos],
        )
      end
    end

    class Envelope
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          attachment: Attachment.from_h(hash[:attachment]),
          gherkin_document: GherkinDocument.from_h(hash[:gherkinDocument]),
          hook: Hook.from_h(hash[:hook]),
          meta: Meta.from_h(hash[:meta]),
          parameter_type: ParameterType.from_h(hash[:parameterType]),
          parse_error: ParseError.from_h(hash[:parseError]),
          pickle: Pickle.from_h(hash[:pickle]),
          source: Source.from_h(hash[:source]),
          step_definition: StepDefinition.from_h(hash[:stepDefinition]),
          test_case: TestCase.from_h(hash[:testCase]),
          test_case_finished: TestCaseFinished.from_h(hash[:testCaseFinished]),
          test_case_started: TestCaseStarted.from_h(hash[:testCaseStarted]),
          test_run_finished: TestRunFinished.from_h(hash[:testRunFinished]),
          test_run_started: TestRunStarted.from_h(hash[:testRunStarted]),
          test_step_finished: TestStepFinished.from_h(hash[:testStepFinished]),
          test_step_started: TestStepStarted.from_h(hash[:testStepStarted]),
          undefined_parameter_type: UndefinedParameterType.from_h(hash[:undefinedParameterType]),
        )
      end
    end

    class GherkinDocument
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          uri: hash[:uri],
          feature: Feature.from_h(hash[:feature]),
          comments: hash[:comments]&.map { |item| Comment.from_h(item) },
        )
      end
    end

    class Background
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          steps: hash[:steps]&.map { |item| Step.from_h(item) },
          id: hash[:id],
        )
      end
    end

    class Comment
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          text: hash[:text],
        )
      end
    end

    class DataTable
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          rows: hash[:rows]&.map { |item| TableRow.from_h(item) },
        )
      end
    end

    class DocString
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          media_type: hash[:mediaType],
          content: hash[:content],
          delimiter: hash[:delimiter],
        )
      end
    end

    class Examples
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          tags: hash[:tags]&.map { |item| Tag.from_h(item) },
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          table_header: TableRow.from_h(hash[:tableHeader]),
          table_body: hash[:tableBody]&.map { |item| TableRow.from_h(item) },
          id: hash[:id],
        )
      end
    end

    class Feature
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          tags: hash[:tags]&.map { |item| Tag.from_h(item) },
          language: hash[:language],
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          children: hash[:children]&.map { |item| FeatureChild.from_h(item) },
        )
      end
    end

    class FeatureChild
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          rule: Rule.from_h(hash[:rule]),
          background: Background.from_h(hash[:background]),
          scenario: Scenario.from_h(hash[:scenario]),
        )
      end
    end

    class Rule
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          tags: hash[:tags]&.map { |item| Tag.from_h(item) },
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          children: hash[:children]&.map { |item| RuleChild.from_h(item) },
          id: hash[:id],
        )
      end
    end

    class RuleChild
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          background: Background.from_h(hash[:background]),
          scenario: Scenario.from_h(hash[:scenario]),
        )
      end
    end

    class Scenario
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          tags: hash[:tags]&.map { |item| Tag.from_h(item) },
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          steps: hash[:steps]&.map { |item| Step.from_h(item) },
          examples: hash[:examples]&.map { |item| Examples.from_h(item) },
          id: hash[:id],
        )
      end
    end

    class Step
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          keyword: hash[:keyword],
          text: hash[:text],
          doc_string: DocString.from_h(hash[:docString]),
          data_table: DataTable.from_h(hash[:dataTable]),
          id: hash[:id],
        )
      end
    end

    class TableCell
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          value: hash[:value],
        )
      end
    end

    class TableRow
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          cells: hash[:cells]&.map { |item| TableCell.from_h(item) },
          id: hash[:id],
        )
      end
    end

    class Tag
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          location: Location.from_h(hash[:location]),
          name: hash[:name],
          id: hash[:id],
        )
      end
    end

    class Hook
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          id: hash[:id],
          source_reference: SourceReference.from_h(hash[:sourceReference]),
          tag_expression: hash[:tagExpression],
        )
      end
    end

    class Location
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          line: hash[:line],
          column: hash[:column],
        )
      end
    end

    class Meta
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          protocol_version: hash[:protocolVersion],
          implementation: Product.from_h(hash[:implementation]),
          runtime: Product.from_h(hash[:runtime]),
          os: Product.from_h(hash[:os]),
          cpu: Product.from_h(hash[:cpu]),
          ci: Ci.from_h(hash[:ci]),
        )
      end
    end

    class Ci
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          name: hash[:name],
          url: hash[:url],
          git: Git.from_h(hash[:git]),
        )
      end
    end

    class Git
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          remote: hash[:remote],
          revision: hash[:revision],
          branch: hash[:branch],
          tag: hash[:tag],
        )
      end
    end

    class Product
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          name: hash[:name],
          version: hash[:version],
        )
      end
    end

    class ParameterType
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          name: hash[:name],
          regular_expressions: hash[:regularExpressions],
          prefer_for_regular_expression_match: hash[:preferForRegularExpressionMatch],
          use_for_snippets: hash[:useForSnippets],
          id: hash[:id],
        )
      end
    end

    class ParseError
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          source: SourceReference.from_h(hash[:source]),
          message: hash[:message],
        )
      end
    end

    class Pickle
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          id: hash[:id],
          uri: hash[:uri],
          name: hash[:name],
          language: hash[:language],
          steps: hash[:steps]&.map { |item| PickleStep.from_h(item) },
          tags: hash[:tags]&.map { |item| PickleTag.from_h(item) },
          ast_node_ids: hash[:astNodeIds],
        )
      end
    end

    class PickleDocString
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          media_type: hash[:mediaType],
          content: hash[:content],
        )
      end
    end

    class PickleStep
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          argument: PickleStepArgument.from_h(hash[:argument]),
          ast_node_ids: hash[:astNodeIds],
          id: hash[:id],
          text: hash[:text],
        )
      end
    end

    class PickleStepArgument
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          doc_string: PickleDocString.from_h(hash[:docString]),
          data_table: PickleTable.from_h(hash[:dataTable]),
        )
      end
    end

    class PickleTable
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          rows: hash[:rows]&.map { |item| PickleTableRow.from_h(item) },
        )
      end
    end

    class PickleTableCell
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          value: hash[:value],
        )
      end
    end

    class PickleTableRow
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          cells: hash[:cells]&.map { |item| PickleTableCell.from_h(item) },
        )
      end
    end

    class PickleTag
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          name: hash[:name],
          ast_node_id: hash[:astNodeId],
        )
      end
    end

    class Source
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          uri: hash[:uri],
          data: hash[:data],
          media_type: hash[:mediaType],
        )
      end
    end

    class SourceReference
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          uri: hash[:uri],
          java_method: JavaMethod.from_h(hash[:javaMethod]),
          java_stack_trace_element: JavaStackTraceElement.from_h(hash[:javaStackTraceElement]),
          location: Location.from_h(hash[:location]),
        )
      end
    end

    class JavaMethod
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          class_name: hash[:className],
          method_name: hash[:methodName],
          method_parameter_types: hash[:methodParameterTypes],
        )
      end
    end

    class JavaStackTraceElement
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          class_name: hash[:className],
          file_name: hash[:fileName],
          method_name: hash[:methodName],
        )
      end
    end

    class StepDefinition
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          id: hash[:id],
          pattern: StepDefinitionPattern.from_h(hash[:pattern]),
          source_reference: SourceReference.from_h(hash[:sourceReference]),
        )
      end
    end

    class StepDefinitionPattern
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          source: hash[:source],
          type: hash[:type],
        )
      end
    end

    class TestCase
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          id: hash[:id],
          pickle_id: hash[:pickleId],
          test_steps: hash[:testSteps]&.map { |item| TestStep.from_h(item) },
        )
      end
    end

    class Group
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          children: hash[:children]&.map { |item| Group.from_h(item) },
          start: hash[:start],
          value: hash[:value],
        )
      end
    end

    class StepMatchArgument
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          group: Group.from_h(hash[:group]),
          parameter_type_name: hash[:parameterTypeName],
        )
      end
    end

    class StepMatchArgumentsList
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          step_match_arguments: hash[:stepMatchArguments]&.map { |item| StepMatchArgument.from_h(item) },
        )
      end
    end

    class TestStep
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          hook_id: hash[:hookId],
          id: hash[:id],
          pickle_step_id: hash[:pickleStepId],
          step_definition_ids: hash[:stepDefinitionIds],
          step_match_arguments_lists: hash[:stepMatchArgumentsLists]&.map { |item| StepMatchArgumentsList.from_h(item) },
        )
      end
    end

    class TestCaseFinished
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          test_case_started_id: hash[:testCaseStartedId],
          timestamp: Timestamp.from_h(hash[:timestamp]),
        )
      end
    end

    class TestCaseStarted
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          attempt: hash[:attempt],
          id: hash[:id],
          test_case_id: hash[:testCaseId],
          timestamp: Timestamp.from_h(hash[:timestamp]),
        )
      end
    end

    class TestRunFinished
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          message: hash[:message],
          success: hash[:success],
          timestamp: Timestamp.from_h(hash[:timestamp]),
        )
      end
    end

    class TestRunStarted
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          timestamp: Timestamp.from_h(hash[:timestamp]),
        )
      end
    end

    class TestStepFinished
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          test_case_started_id: hash[:testCaseStartedId],
          test_step_id: hash[:testStepId],
          test_step_result: TestStepResult.from_h(hash[:testStepResult]),
          timestamp: Timestamp.from_h(hash[:timestamp]),
        )
      end
    end

    class TestStepResult
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          duration: Duration.from_h(hash[:duration]),
          message: hash[:message],
          status: hash[:status],
          will_be_retried: hash[:willBeRetried],
        )
      end
    end

    class TestStepStarted
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          test_case_started_id: hash[:testCaseStartedId],
          test_step_id: hash[:testStepId],
          timestamp: Timestamp.from_h(hash[:timestamp]),
        )
      end
    end

    class Timestamp
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          seconds: hash[:seconds],
          nanos: hash[:nanos],
        )
      end
    end

    class UndefinedParameterType
      def self.from_h(hash)
        return nil if hash.nil?

        self.new(
          expression: hash[:expression],
          name: hash[:name],
        )
      end
    end
  end
end
